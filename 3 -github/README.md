# Intro to Github

### Example 1

1. Let’s say you're working with another person on a project
2. Together you both have to create a powerpoint presentation for a semminar
3. Before you part ways, you'll create a structure for presentation
4. You work on this, Your partner will work on that...
5. ... Now, you meet again and you've chosen different colour schemes, used different fonts and styles to eachother

What if there were a way to automate the merging of your material, where you could choose what to keep and what not to keep?

### Example 2

1. Another scenario could be you working on your CV
2. Over the years, you would have made an array of edits to your CV
3. You'd have to save all the different versions across files

What if you could see exactly what changes you’ve made and where over time?

## Lesson One - version control

Version control, is the key to collaborative software development. You can work in teams on the same project, easily manage conflicts in code on the same files, work on different versions all at the same time and then decide what you want to keep and what you want to bin at the end

To be concise, this is why we need it:

* Backup and Restore
  Files are saved as they are edited, and you can jump to any moment in time. Need that file as it was on Feb 23, 2007? No problem.

* Synchronization
  Lets people share files and stay up-to-date with the latest version.

● Short-term undo. Monkeying with a file and messed it up? (That’s

just like you, isn’t it?). Throw away your changes and go back to the

“last known good” version in the database.

● Long-term undo. Sometimes we mess up bad. Suppose you made

a change a year ago, and it had a bug. Jump back to the old version,

and see what change was made that day.

● Track Changes. As files are updated, you can leave messages

explaining why the change happened (stored in the VCS, not the

file). This makes it easy to see how a file is evolving over time, and

why.

● Track Ownership. A VCS tags every change with the name of the

person who made it. Helpful for blamestorming giving credit.

● Sandboxing, or insurance against yourself. Making a big change?

You can make temporary changes in an isolated area, test and work

out the kinks before “checking in” your changes.

● Branching and merging. A larger sandbox. You can branch a

copy of your code into a separate area and modify it in isolation

(tracking changes separately). Later, you can merge your work

back into the common area.
